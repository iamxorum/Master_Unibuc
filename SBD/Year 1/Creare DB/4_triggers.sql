SAVEPOINT start_transaction;

CREATE OR REPLACE TRIGGER TRG_PACIENT_ID
    BEFORE INSERT ON PACIENT
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_PACIENT_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_MEDIC_ID
    BEFORE INSERT ON MEDIC
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_MEDIC_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_PROGRAMARE_ID
    BEFORE INSERT ON PROGRAMARE
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_PROGRAMARE_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_CONSULTATIE_ID
    BEFORE INSERT ON CONSULTATIE
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_CONSULTATIE_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_RETETA_ID
    BEFORE INSERT ON RETETA
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_RETETA_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_MEDICAMENT_ID
    BEFORE INSERT ON MEDICAMENT
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_MEDICAMENT_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_ALERGIE_ID
    BEFORE INSERT ON ALERGIE
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_ALERGIE_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_SPECIALIZARE_ID
    BEFORE INSERT ON SPECIALIZARE
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_SPECIALIZARE_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_DEPARTAMENT_ID
    BEFORE INSERT ON DEPARTAMENT
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        :NEW.ID := SEQ_DEPARTAMENT_ID.NEXTVAL;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_RETETA_UNIQUE_CONSULTATIE
    BEFORE INSERT OR UPDATE ON RETETA
    FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM RETETA
    WHERE IDConsultatie = :NEW.IDConsultatie
    AND (:NEW.ID IS NULL OR ID != :NEW.ID);
    
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'O consultație poate avea o singură rețetă.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_CONSULTATIE_UNIQUE_PROGRAMARE
    BEFORE INSERT OR UPDATE ON CONSULTATIE
    FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM CONSULTATIE
    WHERE IDProgramare = :NEW.IDProgramare
    AND (:NEW.ID IS NULL OR ID != :NEW.ID);
    
    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'O programare poate avea o singură consultație.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_RETETA_MEDICAMENT_STOC
    BEFORE INSERT OR UPDATE ON RETETA_MEDICAMENT
    FOR EACH ROW
DECLARE
    v_stoc_disponibil NUMBER;
BEGIN
    SELECT StocDisponibil
    INTO v_stoc_disponibil
    FROM MEDICAMENT
    WHERE ID = :NEW.IDMedicament;
    
    IF :NEW.Cantitate > v_stoc_disponibil THEN
        RAISE_APPLICATION_ERROR(-20001, 'Cantitatea solicitată depășește stocul disponibil.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_RETETA_MEDICAMENT_UPDATE_STOC
    AFTER INSERT OR UPDATE OR DELETE ON RETETA_MEDICAMENT
    FOR EACH ROW
BEGIN
    IF INSERTING THEN
        UPDATE MEDICAMENT
        SET StocDisponibil = StocDisponibil - :NEW.Cantitate
        WHERE ID = :NEW.IDMedicament;
    ELSIF UPDATING THEN
        UPDATE MEDICAMENT
        SET StocDisponibil = StocDisponibil + :OLD.Cantitate - :NEW.Cantitate
        WHERE ID = :NEW.IDMedicament;
    ELSIF DELETING THEN
        UPDATE MEDICAMENT
        SET StocDisponibil = StocDisponibil + :OLD.Cantitate
        WHERE ID = :OLD.IDMedicament;
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_PACIENT_DATA_NASTERII
    BEFORE INSERT OR UPDATE OF DataNasterii ON PACIENT
    FOR EACH ROW
BEGIN
    IF :NEW.DataNasterii >= SYSDATE THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data nașterii trebuie să fie în trecut.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_MEDIC_DATA_ANGAJARE
    BEFORE INSERT OR UPDATE OF DataAngajare ON MEDIC
    FOR EACH ROW
BEGIN
    IF :NEW.DataAngajare > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data angajării nu poate fi în viitor.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_PROGRAMARE_DATA
    BEFORE INSERT OR UPDATE OF DataProgramare ON PROGRAMARE
    FOR EACH ROW
BEGIN
    IF :NEW.DataProgramare < TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data programării nu poate fi în trecut.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_MEDIC_SPECIALIZARE_DATA
    BEFORE INSERT OR UPDATE OF DataObtinere ON MEDIC_SPECIALIZARE
    FOR EACH ROW
BEGIN
    IF :NEW.DataObtinere > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data obținerii specializării nu poate fi în viitor.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_PACIENT_ALERGIE_DATA
    BEFORE INSERT OR UPDATE OF DataDiagnostic ON PACIENT_ALERGIE
    FOR EACH ROW
BEGIN
    IF :NEW.DataDiagnostic > TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data diagnosticului nu poate fi în viitor.');
    END IF;
END;

CREATE OR REPLACE TRIGGER TRG_CONSULTATIE_DATA
    BEFORE INSERT OR UPDATE OF DataConsultatie ON CONSULTATIE
    FOR EACH ROW
BEGIN
    IF TRUNC(:NEW.DataConsultatie) != TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data consultației trebuie să fie data curentă.');
    END IF;
END;

COMMIT;