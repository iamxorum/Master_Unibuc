# Docker pentru setup

services:
  db:
    image: postgres:16
    container_name: postgres_referat
    restart: always
    environment:
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: admin123
      POSTGRES_DB: referat_db
      POSTGRES_HOST_AUTH_METHOD: scram-sha-256
      POSTGRES_INITDB_ARGS: --auth-host=scram-sha-256
    ports:
      # 10.80.0.40 este IP-ul de la VPS prin conexiune Wireguard VPN
      - "10.80.0.40:5432:5432"
    volumes:
      - db_data:/var/lib/postgresql/data
      - ./conf/pg_hba.conf:/etc/postgresql/pg_hba.conf
    command: ["postgres", "-c", "hba_file=/etc/postgresql/pg_hba.conf"]

volumes:
  db_data:





# Config pentru pg_hba.conf 

# TYPE  DATABASE        USER            ADDRESS                 METHOD
local   all             all                                     scram-sha-256
host    all             all             127.0.0.1/32            scram-sha-256
host    all             all             10.80.0.0/16            scram-sha-256
host    all             all             0.0.0.0/0               reject
host    all             all             ::/0                    reject






# Init schema

CREATE TABLE pacient (
    id_pacient SERIAL PRIMARY KEY,
    nume VARCHAR(50) NOT NULL,
    prenume VARCHAR(50) NOT NULL,
    cnp VARCHAR(13) UNIQUE NOT NULL,
    telefon VARCHAR(15),
    adresa TEXT
);

CREATE TABLE personal_medical (
    id_personal SERIAL PRIMARY KEY,
    nume VARCHAR(50) NOT NULL,
    prenume VARCHAR(50) NOT NULL,
    specializare VARCHAR(50),
    username_db VARCHAR(60) UNIQUE NOT NULL, 
    grad_acreditare INT NOT NULL DEFAULT 1 
);

CREATE TABLE fisa_medicala (
    id_fisa SERIAL PRIMARY KEY,
    id_pacient INT REFERENCES pacient(id_pacient),
    id_medic INT REFERENCES personal_medical(id_personal),
    diagnostic TEXT NOT NULL,
    tratament TEXT,
    data_consultatie TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    nivel_clasificare INT NOT NULL DEFAULT 1 CHECK (nivel_clasificare IN (1, 2, 3))
);

INSERT INTO pacient (nume, prenume, cnp, telefon, adresa) VALUES
('Popescu', 'Ion', '1980123456789', '0712345678', 'Strada Mihai Eminescu, Nr. 10, București'),
('Ionescu', 'Maria', '1990567890123', '0723456789', 'Bulevardul Unirii, Nr. 25, Cluj-Napoca'),
('Georgescu', 'Andrei', '1985123456789', '0734567890', 'Strada Republicii, Nr. 5, Timișoara');

INSERT INTO personal_medical (nume, prenume, specializare, username_db, grad_acreditare) VALUES
('Dr. Popescu', 'Ana', 'Cardiologie', 'ana.popescu', 3),
('Dr. Marinescu', 'Mihai', 'Neurologie', 'mihai.marinescu', 2),
('Dr. Constantinescu', 'Elena', 'Pediatrie', 'elena.constantinescu', 1);

INSERT INTO fisa_medicala (id_pacient, id_medic, diagnostic, tratament, data_consultatie, nivel_clasificare) VALUES
(1, 1, 'Hipertensiune arterială', 'Lisinopril 10mg zilnic, monitorizare tensiune', '2024-01-15 10:30:00', 3),
(2, 2, 'Cefalee tensională', 'Ibuprofen 400mg la nevoie, tehnici de relaxare', '2024-01-20 14:15:00', 2),
(3, 3, 'Infecție respiratorie superioară', 'Amoxicilină 500mg de 3 ori pe zi timp de 7 zile', '2024-01-25 09:00:00', 1);






# Access control - RBAC cu testare

CREATE ROLE rol_medic;
CREATE ROLE rol_asistent;
CREATE ROLE rol_rezident;

GRANT ALL ON fisa_medicala TO rol_medic;
GRANT ALL ON pacient TO rol_medic;
GRANT ALL ON personal_medical TO rol_medic;

GRANT SELECT ON pacient TO rol_asistent;
GRANT SELECT ON fisa_medicala TO rol_asistent;
GRANT SELECT ON personal_medical TO rol_asistent;

GRANT SELECT ON fisa_medicala TO rol_rezident;

CREATE USER "ana.popescu" WITH PASSWORD 'parola123';
GRANT rol_medic TO "ana.popescu";

CREATE USER "mihai.marinescu" WITH PASSWORD 'parola123';
GRANT rol_asistent TO "mihai.marinescu";

CREATE USER "elena.constantinescu" WITH PASSWORD 'parola123';
GRANT rol_rezident TO "elena.constantinescu";

-- Verificare membri ai rolurilor
SELECT r.rolname AS role_name, m.rolname AS member_name
FROM pg_roles r
JOIN pg_auth_members am ON r.oid = am.roleid
JOIN pg_roles m ON am.member = m.oid
WHERE r.rolname LIKE 'rol_%'
ORDER BY r.rolname, m.rolname;

-- Verificare permisiuni pe tabele pentru fiecare rol
SELECT 
    grantee AS role_name,
    table_name,
    string_agg(privilege_type, ', ' ORDER BY privilege_type) AS privileges
FROM information_schema.role_table_grants
WHERE grantee LIKE 'rol_%'
    AND table_schema = 'public'
GROUP BY grantee, table_name
ORDER BY grantee, table_name;

# Access control - MAC

GRANT SELECT ON personal_medical TO "ana.popescu";
GRANT SELECT ON personal_medical TO "mihai.marinescu";
GRANT SELECT ON personal_medical TO "elena.constantinescu";

GRANT SELECT ON fisa_medicala TO "ana.popescu";
GRANT SELECT ON fisa_medicala TO "mihai.marinescu";
GRANT SELECT ON fisa_medicala TO "elena.constantinescu";

ALTER TABLE fisa_medicala ENABLE ROW LEVEL SECURITY;

CREATE POLICY politica_mac_fise ON fisa_medicala
FOR SELECT
USING (
    (SELECT grad_acreditare 
     FROM personal_medical 
     WHERE username_db = current_user) >= nivel_clasificare
);

ALTER TABLE fisa_medicala FORCE ROW LEVEL SECURITY; 

# Access control - DAC

CREATE USER "ana.popescu" WITH PASSWORD 'parola123';
CREATE USER "mihai.marinescu" WITH PASSWORD 'parola123';
CREATE USER "elena.constantinescu" WITH PASSWORD 'parola123';

GRANT SELECT ON fisa_medicala TO "ana.popescu" WITH GRANT OPTION;





# Audit

CREATE TABLE audit_log (
    id SERIAL PRIMARY KEY,
    tabel_nume VARCHAR(100) NOT NULL,
    operatie VARCHAR(10) NOT NULL, -- INSERT, UPDATE, DELETE
    utilizator VARCHAR(100) NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    date_vechi JSONB,
    date_noi JSONB,
    ip_adresa INET
);

CREATE OR REPLACE FUNCTION audit_trigger_func()
RETURNS TRIGGER 
SECURITY DEFINER
AS $$
BEGIN
    IF (TG_OP = 'DELETE') THEN
        INSERT INTO audit_log (tabel_nume, operatie, utilizator, date_vechi, ip_adresa)
        VALUES (TG_TABLE_NAME, TG_OP, session_user, row_to_json(OLD), inet_client_addr());
        RETURN OLD;
    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO audit_log (tabel_nume, operatie, utilizator, date_vechi, date_noi, ip_adresa)
        VALUES (TG_TABLE_NAME, TG_OP, session_user, row_to_json(OLD), row_to_json(NEW), inet_client_addr());
        RETURN NEW;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO audit_log (tabel_nume, operatie, utilizator, date_noi, ip_adresa)
        VALUES (TG_TABLE_NAME, TG_OP, session_user, row_to_json(NEW), inet_client_addr());
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER audit_fisa_medicala
AFTER INSERT OR UPDATE OR DELETE ON fisa_medicala
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

CREATE TRIGGER audit_pacient
AFTER INSERT OR UPDATE OR DELETE ON pacient
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

CREATE TRIGGER audit_personal_medical
AFTER INSERT OR UPDATE OR DELETE ON personal_medical
FOR EACH ROW EXECUTE FUNCTION audit_trigger_func();

GRANT SELECT ON audit_log TO admin;





# Criptare/Decriptare

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE IF NOT EXISTS pacient_encrypted (
    id_pacient SERIAL PRIMARY KEY,
    nume VARCHAR(50) NOT NULL,
    prenume VARCHAR(50) NOT NULL,
    cnp_encrypted BYTEA,  -- CNP criptat
    telefon VARCHAR(15),
    adresa TEXT
);

CREATE OR REPLACE FUNCTION encrypt_cnp(cnp_plain VARCHAR, encryption_key TEXT)
RETURNS BYTEA AS $$
BEGIN
    RETURN pgp_sym_encrypt(cnp_plain, encryption_key);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION decrypt_cnp(cnp_encrypted BYTEA, encryption_key TEXT)
RETURNS VARCHAR AS $$
BEGIN
    RETURN pgp_sym_decrypt(cnp_encrypted, encryption_key);
END;
$$ LANGUAGE plpgsql;

INSERT INTO pacient_encrypted (nume, prenume, cnp_encrypted, telefon, adresa)
VALUES (
    'Popescu',
    'Ion',
    encrypt_cnp('1980123456789', 'portocal12'),
    '0712345678',
    'Strada Mihai Eminescu, Nr. 10, București'
);

SELECT 
    id_pacient,
    nume,
    prenume,
    decrypt_cnp(cnp_encrypted, 'portocal12') AS cnp_decriptat,
    telefon,
    adresa
FROM pacient_encrypted
WHERE nume = 'Popescu';

ALTER TABLE pacient
ALTER COLUMN cnp TYPE BYTEA
USING encrypt_cnp(cnp, 'portocal12');








# SQL Injection

PREPARE get_pacient (VARCHAR, VARCHAR) AS
SELECT * FROM pacient WHERE nume = $1 AND cnp = $2;

EXECUTE get_pacient('Popescu', '1980123456789');

CREATE OR REPLACE FUNCTION get_pacient_by_cnp(cnp_param VARCHAR)
RETURNS TABLE (
    id_pacient INT,
    nume VARCHAR,
    prenume VARCHAR,
    cnp VARCHAR,
    telefon VARCHAR,
    adresa TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT p.id_pacient, p.nume, p.prenume, p.cnp, p.telefon, p.adresa
    FROM pacient p
    WHERE p.cnp = cnp_param;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

SELECT * FROM get_pacient_by_cnp('1980123456789');








# Views (Visualiari)

CREATE OR REPLACE VIEW pacient_public AS
SELECT 
    id_pacient,
    nume,
    prenume,
    telefon
FROM pacient;

CREATE OR REPLACE VIEW personal_public AS
SELECT 
    id_personal,
    nume,
    prenume,
    specializare
FROM personal_medical;

CREATE OR REPLACE VIEW fisa_medicala_personal AS
SELECT 
    f.id_fisa,
    f.id_pacient,
    p.nume AS nume_pacient,
    p.prenume AS prenume_pacient,
    f.diagnostic,
    f.tratament,
    f.data_consultatie
FROM fisa_medicala f
JOIN pacient p ON f.id_pacient = p.id_pacient
JOIN personal_medical pm ON f.id_medic = pm.id_personal
WHERE pm.username_db = current_user;

GRANT SELECT ON pacient_public TO rol_asistent;
GRANT SELECT ON personal_public TO rol_asistent;
GRANT SELECT ON fisa_medicala_personal TO rol_medic;


